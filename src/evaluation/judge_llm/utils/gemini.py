import os
import time
import json
import google.generativeai as genai
import ollama
from typing import Dict, List
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

MODEL_STATE = {
    'exhausted_models': set(),
    'model_cooldowns': {},
    'last_reset_time': time.time()
}

COOLDOWN_DURATION = 3600

LOCAL_JUDGE_FALLBACK = 'gemma2:2b'

GEMINI_FALLBACK_ORDER = [
    'gemini-2.5-pro', 'gemini-2.5-flash', 'gemini-2.0-flash-lite', 'gemini-1.5-flash'
]

def setup_gemini():
    api_key = os.getenv('GEMINI_API_KEY')
    if api_key:
        genai.configure(api_key=api_key)
        return True
    return False

def is_model_available(model_name: str) -> bool:
    current_time = time.time()
    if model_name in MODEL_STATE['exhausted_models']:
        if current_time - MODEL_STATE['model_cooldowns'].get(model_name, 0) > COOLDOWN_DURATION:
            MODEL_STATE['exhausted_models'].discard(model_name)
            return True
        return False
    return True

def judge_recipe(dish_name: str, recipe_content: str, chef_name: str) -> Dict:
    """
    The core function that sends the recipe to an LLM (Gemini or Ollama) 
    to get a score (1-10) and reasoning.
    """
    if not recipe_content:
        return {"score": 0, "reasoning": "Recipe generation failed (empty output).", "judge_model": "None"}

    # The Prompt for the Judge
    prompt = f"""
    Act as a culinary critic evaluating a lightweight AI model (0.5B parameters). 
    Evaluate this recipe for "{dish_name}" generated by model "{chef_name}".
    
    RECIPE:
    {recipe_content[:4000]}... (truncated if too long)

    CRITERIA:
    1. Does it actually make "{dish_name}"? (Crucial)
    2. Are the instructions logical and safe?
    3. Are the ingredients standard for this dish?
    
    SCORING CONTEXT:
    - Since this is a small model, be lenient on simple phrasing or lack of "flair".
    - Be STRICT on hallucinations (inventing non-existent ingredients), loops/repetition, or dangerous steps.
    - If the recipe is basically correct but simple, give it a passing score (5+).
    
    Respond ONLY with this JSON format:
    {{
        "score": <int 1-10>,
        "reasoning": "<short explanation string>"
    }}
    """

    # 1. Try Gemini Models in order
    for model in GEMINI_FALLBACK_ORDER:
        if is_model_available(model):
            try:
                m = genai.GenerativeModel(model)
                # Request JSON response type for easier parsing with timeout
                resp = m.generate_content(
                    prompt, 
                    generation_config={
                        "response_mime_type": "application/json",
                        "temperature": 0.7
                    },
                    request_options={"timeout": 30}
                )
                result = json.loads(resp.text)
                result["judge_model"] = model
                return result
            except Exception as e:
                print(f"‚ö†Ô∏è {model} failed or quota exceeded: {str(e)[:100]}. Switching...")
                MODEL_STATE["exhausted_models"].add(model)
                MODEL_STATE["model_cooldowns"][model] = time.time()

    # 2. Fallback to Local Ollama (Gemma) if all APIs fail
    print(f"üîå API exhausted. Falling back to local judge: {LOCAL_JUDGE_FALLBACK}")
    try:
        resp = ollama.chat(
            model=LOCAL_JUDGE_FALLBACK, 
            messages=[{"role": "user", "content": prompt}]
        )
        # Local models might output markdown like ```json ... ```
        clean_json = (
            resp["message"]["content"]
            .replace("```json", "")
            .replace("```", "")
            .strip()
        )
        result = json.loads(clean_json)
        result["judge_model"] = LOCAL_JUDGE_FALLBACK
        return result
    except Exception as e:
        return {"score": 0, "reasoning": f"Judge Error: {str(e)}", "judge_model": "None"}
